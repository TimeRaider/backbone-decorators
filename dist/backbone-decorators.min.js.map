{"version":3,"sources":["/source/backbone-decorators.js","/source/src/backbone-decorators.js","backbone-decorators.min.js"],"names":["global","factory","exports","module","require","define","amd","Decorators","_","Backbone","this","onDecoratorFactory","decoratorName","propertyName","eventName","target","name","descriptor","Error","isFunction","has","clone","tagName","value","prototype","model","modelClass","Model","comparator","comparatorString","isString","defaults","_len","arguments","length","args","Array","_key","key","isObject","extend","isUndefined","route","routeName","routes","template","childView","childViewContainer","ui","_len2","_key2","useSuper","superMethod","Object","getPrototypeOf","_len3","_key3","apply","localStorage","storageKey","LocalStorage","replyRadio","channel","requestString","radioRequests","on","onModel","onCollection","onChild"],"mappings":"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","file":"backbone-decorators.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('underscore'), require('backbone')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'underscore', 'backbone'], factory) :\n    factory((global.Decorators = {}), global._, global.Backbone)\n}(this, function (exports, _, Backbone) { 'use strict';\n\n    _ = ('default' in _ ? _['default'] : _);\n    Backbone = ('default' in Backbone ? Backbone['default'] : Backbone);\n\n    /* Ideally we'd want to just pass these exports through directly\n     * but Babel complains about nesting exports, so we attach them\n     * to a namespace\n     */\n\n    function onDecoratorFactory(decoratorName, propertyName) {\n        return function(eventName) {\n             return function(target, name, descriptor) {\n                 if (!eventName) {\n                     throw new Error(`The ${decoratorName} decorator requires an eventName argument`);\n                 }\n                 if (_.isFunction(target[propertyName])) {\n                     throw new Error(`The ${decoratorName} decorator is not compatible with ${propertyName} as method form`);\n                     return;\n                 }\n                 if (target[propertyName] && !_.has(target, propertyName)) {\n                     target[propertyName] = _.clone(target[propertyName]);\n                 }\n                 if (!target[propertyName]) {\n                     target[propertyName] = {};\n                 }\n                 target[propertyName][eventName] = name;\n                 return descriptor;\n             };\n         };\n    }\n\n    // Backbone Decorators\n\n    // Views\n\n    const on = onDecoratorFactory('on', 'events');\n\n    function tagName(value) {\n        return function decorator(target) {\n            target.prototype.tagName = value;\n        };\n    }\n\n    //Collections\n\n    function model(modelClass) {\n        return function decorator(target) {\n            if (modelClass.prototype instanceof Backbone.Model) {\n                target.prototype.model = modelClass;\n            } else {\n                throw new Error('The model decorator takes either a single argument that should be an instance of Backbone.Model');\n            }\n        };\n    }\n\n    function comparator(comparatorString) {\n        return function decorator(target) {\n            if (_.isString(comparatorString)) {\n                target.prototype.comparator = comparatorString;\n            } else {\n                throw new Error('The comparator decorator takes either a single argument that should be a string');\n            }\n        };\n    }\n\n    //Models\n\n    function defaults(...args) {\n        return function decorator(target) {\n            let defaults = target.prototype.defaults || {};\n            let [key, value] = args;\n            if (_.isObject(key)) {\n                _.extend(defaults, key);\n            } else if (_.isString(key) && !_.isUndefined(value)) {\n                defaults[key] = value;\n            } else {\n                throw new Error('The defaults decorator takes either a single object as an argument or a key and value');\n            }\n            target.prototype.defaults = defaults;\n        };\n    }\n\n    //Router\n\n    function route(routeName) {\n        return function(target, name, descriptor) {\n            if (!target.routes) {\n                target.routes = {};\n            }\n            if (_.isFunction(target.routes)) {\n                throw new Error('The route decorator is not compatible with a route method');\n                return;\n            }\n            if (!routeName) {\n                throw new Error('The route decorator requires an route string argument');\n            }\n            target.routes[routeName] = name;\n            return descriptor;\n        };\n    }\n\n    // Marionette Decorators\n\n    // Views\n\n    const onModel = onDecoratorFactory('onModel', 'modelEvents');\n    const onCollection = onDecoratorFactory('onCollection', 'modelEvents');\n    const onChild = onDecoratorFactory('onChild', 'childEvents');\n\n    function template(value) {\n        return function decorator(target) {\n            target.prototype.template = value;\n        };\n    }\n\n    function childView(value) {\n        return function decorator(target) {\n            target.prototype.childView = value;\n        };\n    }\n\n    function childViewContainer(value) {\n        return function decorator(target) {\n            target.prototype.childViewContainer = value;\n        };\n    }\n\n    function ui(...args) {\n        return function decorator(target) {\n            let ui = target.prototype.ui || {};\n            let [key, value] = args;\n            if (_.isObject(key)) {\n                _.extend(ui, args[0]);\n            } else if (_.isString(key) && _.isString(value)) {\n                ui[key] = value;\n            } else {\n                throw new Error('The ui decorator takes either a single object as an argument or a key and value string');\n            }\n            target.prototype.ui = ui;\n        };\n    }\n\n    // Utility Decorators\n\n    function useSuper(target, name, descriptor) {\n        let superMethod = Object.getPrototypeOf(target)[name];\n        if (_.isFunction(superMethod)) {\n            descriptor.value = function(...args) {\n                superMethod.apply(this, args);\n            };\n        } else {\n            throw new Error('The useSuper method requires the parent class to implement this function somewhere on its prototype chain');\n        }\n        return descriptor;\n    }\n\n    //Backbone.LocalStorage Decorators\n\n    function localStorage(storageKey) {\n        return function decorator(target) {\n            if (Backbone.LocalStorage) {\n                if (_.isString(storageKey)) {\n                    target.prototype.localStorage = new Backbone.LocalStorage(storageKey);\n                } else {\n                    throw new Error('The localStorage decorator requires a single string argument which will serve as the localStorage key');\n                }\n            } else {\n                throw new Error('The localStorage decorator requires Backbone.LocalStorage to have been loaded before use');\n            }\n        };\n    }\n\n    //Marionette-service Decorators\n\n    function replyRadio(channel, requestString) {\n        return function(target, name, descriptor) {\n            if (!target.radioRequests) {\n                target.radioRequests = {};\n            }\n            if (_.isFunction(target.radioRequests)) {\n                throw new Error('The replyRadio decorator is not compatible with a radioRequests method');\n                return;\n            }\n            if (!_.isString(channel) || !_.isString(requestString)) {\n                throw new Error('The replyRadio decorator requires 2 arguments, a channel and a request string.');\n            }\n            target.radioRequests[channel + ' ' + requestString] = name;\n            return descriptor;\n        };\n    }\n\n    exports.on = on;\n    exports.tagName = tagName;\n    exports.model = model;\n    exports.comparator = comparator;\n    exports.defaults = defaults;\n    exports.route = route;\n    exports.onModel = onModel;\n    exports.onCollection = onCollection;\n    exports.onChild = onChild;\n    exports.template = template;\n    exports.childView = childView;\n    exports.childViewContainer = childViewContainer;\n    exports.ui = ui;\n    exports.useSuper = useSuper;\n    exports.localStorage = localStorage;\n    exports.replyRadio = replyRadio;\n\n}));\n","import _ from 'underscore';\nimport Backbone from 'backbone';\n\n/* Ideally we'd want to just pass these exports through directly\n * but Babel complains about nesting exports, so we attach them\n * to a namespace\n */\n\nfunction onDecoratorFactory(decoratorName, propertyName) {\n    return function(eventName) {\n         return function(target, name, descriptor) {\n             if (!eventName) {\n                 throw new Error(`The ${decoratorName} decorator requires an eventName argument`);\n             }\n             if (_.isFunction(target[propertyName])) {\n                 throw new Error(`The ${decoratorName} decorator is not compatible with ${propertyName} as method form`);\n                 return;\n             }\n             if (target[propertyName] && !_.has(target, propertyName)) {\n                 target[propertyName] = _.clone(target[propertyName]);\n             }\n             if (!target[propertyName]) {\n                 target[propertyName] = {};\n             }\n             target[propertyName][eventName] = name;\n             return descriptor;\n         };\n     };\n}\n\n// Backbone Decorators\n\n// Views\n\nexport const on = onDecoratorFactory('on', 'events');\n\nexport function tagName(value) {\n    return function decorator(target) {\n        target.prototype.tagName = value;\n    };\n}\n\n//Collections\n\nexport function model(modelClass) {\n    return function decorator(target) {\n        if (modelClass.prototype instanceof Backbone.Model) {\n            target.prototype.model = modelClass;\n        } else {\n            throw new Error('The model decorator takes either a single argument that should be an instance of Backbone.Model');\n        }\n    };\n}\n\nexport function comparator(comparatorString) {\n    return function decorator(target) {\n        if (_.isString(comparatorString)) {\n            target.prototype.comparator = comparatorString;\n        } else {\n            throw new Error('The comparator decorator takes either a single argument that should be a string');\n        }\n    };\n}\n\n//Models\n\nexport function defaults(...args) {\n    return function decorator(target) {\n        let defaults = target.prototype.defaults || {};\n        let [key, value] = args;\n        if (_.isObject(key)) {\n            _.extend(defaults, key);\n        } else if (_.isString(key) && !_.isUndefined(value)) {\n            defaults[key] = value;\n        } else {\n            throw new Error('The defaults decorator takes either a single object as an argument or a key and value');\n        }\n        target.prototype.defaults = defaults;\n    };\n}\n\n//Router\n\nexport function route(routeName) {\n    return function(target, name, descriptor) {\n        if (!target.routes) {\n            target.routes = {};\n        }\n        if (_.isFunction(target.routes)) {\n            throw new Error('The route decorator is not compatible with a route method');\n            return;\n        }\n        if (!routeName) {\n            throw new Error('The route decorator requires an route string argument');\n        }\n        target.routes[routeName] = name;\n        return descriptor;\n    };\n}\n\n// Marionette Decorators\n\n// Views\n\nexport const onModel = onDecoratorFactory('onModel', 'modelEvents');\nexport const onCollection = onDecoratorFactory('onCollection', 'modelEvents');\nexport const onChild = onDecoratorFactory('onChild', 'childEvents');\n\nexport function template(value) {\n    return function decorator(target) {\n        target.prototype.template = value;\n    };\n}\n\nexport function childView(value) {\n    return function decorator(target) {\n        target.prototype.childView = value;\n    };\n}\n\nexport function childViewContainer(value) {\n    return function decorator(target) {\n        target.prototype.childViewContainer = value;\n    };\n}\n\nexport function ui(...args) {\n    return function decorator(target) {\n        let ui = target.prototype.ui || {};\n        let [key, value] = args;\n        if (_.isObject(key)) {\n            _.extend(ui, args[0]);\n        } else if (_.isString(key) && _.isString(value)) {\n            ui[key] = value;\n        } else {\n            throw new Error('The ui decorator takes either a single object as an argument or a key and value string');\n        }\n        target.prototype.ui = ui;\n    };\n}\n\n// Utility Decorators\n\nexport function useSuper(target, name, descriptor) {\n    let superMethod = Object.getPrototypeOf(target)[name];\n    if (_.isFunction(superMethod)) {\n        descriptor.value = function(...args) {\n            superMethod.apply(this, args);\n        };\n    } else {\n        throw new Error('The useSuper method requires the parent class to implement this function somewhere on its prototype chain');\n    }\n    return descriptor;\n}\n\n//Backbone.LocalStorage Decorators\n\nexport function localStorage(storageKey) {\n    return function decorator(target) {\n        if (Backbone.LocalStorage) {\n            if (_.isString(storageKey)) {\n                target.prototype.localStorage = new Backbone.LocalStorage(storageKey);\n            } else {\n                throw new Error('The localStorage decorator requires a single string argument which will serve as the localStorage key');\n            }\n        } else {\n            throw new Error('The localStorage decorator requires Backbone.LocalStorage to have been loaded before use');\n        }\n    };\n}\n\n//Marionette-service Decorators\n\nexport function replyRadio(channel, requestString) {\n    return function(target, name, descriptor) {\n        if (!target.radioRequests) {\n            target.radioRequests = {};\n        }\n        if (_.isFunction(target.radioRequests)) {\n            throw new Error('The replyRadio decorator is not compatible with a radioRequests method');\n            return;\n        }\n        if (!_.isString(channel) || !_.isString(requestString)) {\n            throw new Error('The replyRadio decorator requires 2 arguments, a channel and a request string.');\n        }\n        target.radioRequests[channel + ' ' + requestString] = name;\n        return descriptor;\n    };\n}\n","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('underscore'), require('backbone')) : typeof define === 'function' && define.amd ? define(['exports', 'underscore', 'backbone'], factory) : factory(global.Decorators = {}, global._, global.Backbone);\n})(this, function (exports, _, Backbone) {\n    'use strict';\n\n    _ = 'default' in _ ? _['default'] : _;\n    Backbone = 'default' in Backbone ? Backbone['default'] : Backbone;\n\n    /* Ideally we'd want to just pass these exports through directly\n     * but Babel complains about nesting exports, so we attach them\n     * to a namespace\n     */\n\n    function onDecoratorFactory(decoratorName, propertyName) {\n        return function (eventName) {\n            return function (target, name, descriptor) {\n                if (!eventName) {\n                    throw new Error('The ' + decoratorName + ' decorator requires an eventName argument');\n                }\n                if (_.isFunction(target[propertyName])) {\n                    throw new Error('The ' + decoratorName + ' decorator is not compatible with ' + propertyName + ' as method form');\n                    return;\n                }\n                if (target[propertyName] && !_.has(target, propertyName)) {\n                    target[propertyName] = _.clone(target[propertyName]);\n                }\n                if (!target[propertyName]) {\n                    target[propertyName] = {};\n                }\n                target[propertyName][eventName] = name;\n                return descriptor;\n            };\n        };\n    }\n\n    // Backbone Decorators\n\n    // Views\n\n    var on = onDecoratorFactory('on', 'events');\n\n    function tagName(value) {\n        return function decorator(target) {\n            target.prototype.tagName = value;\n        };\n    }\n\n    //Collections\n\n    function model(modelClass) {\n        return function decorator(target) {\n            if (modelClass.prototype instanceof Backbone.Model) {\n                target.prototype.model = modelClass;\n            } else {\n                throw new Error('The model decorator takes either a single argument that should be an instance of Backbone.Model');\n            }\n        };\n    }\n\n    function comparator(comparatorString) {\n        return function decorator(target) {\n            if (_.isString(comparatorString)) {\n                target.prototype.comparator = comparatorString;\n            } else {\n                throw new Error('The comparator decorator takes either a single argument that should be a string');\n            }\n        };\n    }\n\n    //Models\n\n    function defaults() {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        return function decorator(target) {\n            var defaults = target.prototype.defaults || {};\n            var key = args[0];\n            var value = args[1];\n\n            if (_.isObject(key)) {\n                _.extend(defaults, key);\n            } else if (_.isString(key) && !_.isUndefined(value)) {\n                defaults[key] = value;\n            } else {\n                throw new Error('The defaults decorator takes either a single object as an argument or a key and value');\n            }\n            target.prototype.defaults = defaults;\n        };\n    }\n\n    //Router\n\n    function route(routeName) {\n        return function (target, name, descriptor) {\n            if (!target.routes) {\n                target.routes = {};\n            }\n            if (_.isFunction(target.routes)) {\n                throw new Error('The route decorator is not compatible with a route method');\n                return;\n            }\n            if (!routeName) {\n                throw new Error('The route decorator requires an route string argument');\n            }\n            target.routes[routeName] = name;\n            return descriptor;\n        };\n    }\n\n    // Marionette Decorators\n\n    // Views\n\n    var onModel = onDecoratorFactory('onModel', 'modelEvents');\n    var onCollection = onDecoratorFactory('onCollection', 'modelEvents');\n    var onChild = onDecoratorFactory('onChild', 'childEvents');\n\n    function template(value) {\n        return function decorator(target) {\n            target.prototype.template = value;\n        };\n    }\n\n    function childView(value) {\n        return function decorator(target) {\n            target.prototype.childView = value;\n        };\n    }\n\n    function childViewContainer(value) {\n        return function decorator(target) {\n            target.prototype.childViewContainer = value;\n        };\n    }\n\n    function ui() {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n        }\n\n        return function decorator(target) {\n            var ui = target.prototype.ui || {};\n            var key = args[0];\n            var value = args[1];\n\n            if (_.isObject(key)) {\n                _.extend(ui, args[0]);\n            } else if (_.isString(key) && _.isString(value)) {\n                ui[key] = value;\n            } else {\n                throw new Error('The ui decorator takes either a single object as an argument or a key and value string');\n            }\n            target.prototype.ui = ui;\n        };\n    }\n\n    // Utility Decorators\n\n    function useSuper(target, name, descriptor) {\n        var superMethod = Object.getPrototypeOf(target)[name];\n        if (_.isFunction(superMethod)) {\n            descriptor.value = function () {\n                for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                    args[_key3] = arguments[_key3];\n                }\n\n                superMethod.apply(this, args);\n            };\n        } else {\n            throw new Error('The useSuper method requires the parent class to implement this function somewhere on its prototype chain');\n        }\n        return descriptor;\n    }\n\n    //Backbone.LocalStorage Decorators\n\n    function localStorage(storageKey) {\n        return function decorator(target) {\n            if (Backbone.LocalStorage) {\n                if (_.isString(storageKey)) {\n                    target.prototype.localStorage = new Backbone.LocalStorage(storageKey);\n                } else {\n                    throw new Error('The localStorage decorator requires a single string argument which will serve as the localStorage key');\n                }\n            } else {\n                throw new Error('The localStorage decorator requires Backbone.LocalStorage to have been loaded before use');\n            }\n        };\n    }\n\n    //Marionette-service Decorators\n\n    function replyRadio(channel, requestString) {\n        return function (target, name, descriptor) {\n            if (!target.radioRequests) {\n                target.radioRequests = {};\n            }\n            if (_.isFunction(target.radioRequests)) {\n                throw new Error('The replyRadio decorator is not compatible with a radioRequests method');\n                return;\n            }\n            if (!_.isString(channel) || !_.isString(requestString)) {\n                throw new Error('The replyRadio decorator requires 2 arguments, a channel and a request string.');\n            }\n            target.radioRequests[channel + ' ' + requestString] = name;\n            return descriptor;\n        };\n    }\n\n    exports.on = on;\n    exports.tagName = tagName;\n    exports.model = model;\n    exports.comparator = comparator;\n    exports.defaults = defaults;\n    exports.route = route;\n    exports.onModel = onModel;\n    exports.onCollection = onCollection;\n    exports.onChild = onChild;\n    exports.template = template;\n    exports.childView = childView;\n    exports.childViewContainer = childViewContainer;\n    exports.ui = ui;\n    exports.useSuper = useSuper;\n    exports.localStorage = localStorage;\n    exports.replyRadio = replyRadio;\n});\n//# sourceMappingURL=backbone-decorators.js.map\n"],"sourceRoot":"/source/"}